//
//      Kirill Kobelev, Moscow-Paris-Sammamish.
//  -------------------------------------------------
//   All rights reserved. Commercial use without written permission prohibited.
//

#ifndef	TextScan_CondExpr_H
#define	TextScan_CondExpr_H

#ifndef   TextScan_MidScan_H
#error    "This file should not be included directly. Use MidScan.h."
#endif

//------------------------------------------------------------------------
//  ===============  Conditional Expressions Handling  ================
//------------------------------------------------------------------------

//
// Possible result of evaluating the conditional expression. This module can make difference between:
//
//       #undef some_name		-- After this stmt the name is treated as "undefined for sure".
//  (no info about the name)		-- No info is still "no info".
//
enum TConditionalStatus
{
	cexr_hard_false,			// Undoubtful FALSE.
	cexr_hard_true,			// Undoubtful  TRUE.
	cexr_soft_false,			// FALSE with doubt.
	cexr_soft_true,			// TRUE with doubt.
	cexr_undefined,			// No informaiton. Most likely the expression is using variables that
							// were not explicitly defined or undefined.
	cexr_num_types,
};

#define  GET_ACTIVE_STATUS(x)	(((x) == cexr_hard_false || (x) == cexr_soft_false) ? FALSE : TRUE)
#define  GET_SURE_STATUS(x)		(((x) <= cexr_hard_true) ? TRUE : FALSE)

//
// Result of the expression simplification. Conditional expression is compiled into a tree of "code items" that
// represents operands and actions that should be applied to these operands. After scanning, the code tree can
// be simplified. The result of simplification can be either a more simple expression or a constant.
//
enum TCondExprSmplResult
{
	cesr_unsimpl,			// The expression cannot be simplified either because all its operands are variables
							// or because simplification mode does not allow undecoration any of its params.
	cesr_simplif,			// The expression can be simplified, but not up to the pure constant because it contains
							// some unsiplifiable operands.
	cesr_value,				// The result of expression simplification is a numeric value. This value still can be
							// either on doubt or not. This nuance is expressed in the TConditionalStatus.
	cesr_num_types,
};

//
// Mode of processing the "defined(name)" operator when there is no info about the name.
//
enum TCondExprUnknNamesProcMode
{
	ceum_condit,
	ceum_undef_doubt,
	ceum_undef_nodoubt,
	ceum_num_types,
};

//
// Mode of conditional expression simplification.
//
struct TCondExprSimplificationProps
{
	bool								smpl_simplif;
	TCondExprUnknNamesProcMode		unkn_names;
	bool								smpl_constants;

	void InitForOrdinaryParsing()
	{
		smpl_simplif = TRUE;
		unkn_names = ceum_undef_nodoubt;
		smpl_constants = TRUE;
	}
};

class TLexemaListItem : public TListItem
{
public:

	TLexemaListItem(TLexema &lexema) { lex = lexema; primary_src = TRUE; }

	TLexema		lex;
	bool			primary_src;	// This flag is used for distinguishing between lexemas that were picked up from the conditional
								// expression source and lexemas, that were created during the expression simplification.
};

class TLexemasList : public TList { };

enum TCondExprArithmPrt
{
	ceprt_lowest,
	ceprt_comma,		ceprt_condit,
	ceprt_logor,			ceprt_logand,
	ceprt_bitor,			ceprt_bitxor,		ceprt_bitand,
	ceprt_eqne,			ceprt_compar,		ceprt_shift,
	ceprt_sum,			ceprt_mul,			ceprt_unary,
	ceprt_highest,
};

//
// Types of tree nodes that represent the compiled expression.
//
enum TCondExprTreeItemType
{
	cecit_value,				// This type of item can be present only in the simpified expression as a result of
							// some computation. It cannot be generated by the cond expression scanner.
	cecit_constant,			// Literal constant (ltx_number or ltx_charconst), that was picked up from the source
							// code of the conditional expression. It is an operand of arithmetic operation.
	cecit_decorated,			// The nature of this type is constant. It was introduced because it is necessary
							// to store the info about the macro that generated this constant.
	cecit_name_def,			// Defined/undefined state of some known name. Note that any name can be used
							// here, not only the "single numeric const" macros.
	cecit_variable,			// Representation of the unknown or undefined name when it is used as an operand
							// of an arithmetic operation.
	cecit_variab_def,		// Unknown name when it is used as a parameter of the "defined" operation. Note that
							// known but undefined names are represented with the "cecit_name_def" code items.
	cecit_operation,			// Operation of the expression. This operation can be either an original operation or
							// the result of computation.
	cecit_num_types,
};

class TCondExprHelper
{
public:

	static const wchar_t	*GetCondStatusName(wchar_t *buff_80_chars, TConditionalStatus val, bool code_status_mode);
	static const wchar_t	*GetCondStatusEnumName(wchar_t *buff_80_chars, TConditionalStatus val);
	static const wchar_t	*GetSmplResultName(wchar_t *buff_80_chars, TCondExprSmplResult val, bool long_form);
	static const wchar_t	*GetUnknNamesProcModeName(wchar_t *buff_80_chars, TCondExprUnknNamesProcMode val);
	static const wchar_t	*GetCondExprTreeItemTypeName(wchar_t *buff_80_chars, TCondExprTreeItemType val, bool long_form);
							// These methods convert enum member values into strings.
};

class TKeyInfoItem;

//
// The final result of evaluating the conditional expression is bool. At the same time conditional expressions allow
// arithmetic operations like +, -, >>, etc. These intermediate results are stored in the TCondExprIntermediateValue
// type. Note that it is a signed value. The unsigned arithmetic is not supported.
//
typedef __int64  TCondExprIntermediateValue;

class TCondExprTreeItem : public TListItem
{
public:

	//
	//  Ctors for different types of the code items.
	//
	//  NB: Constructors do not fill the source list except for the "variable" types of code items.
	//

	TCondExprTreeItem(TCondExprIntermediateValue computed_value, bool val_on_doubt);
			// This is creation of the value object without any origin at all. It is expected that source definition lexemas
			// will be added to this object later.
			// (=== cecit_value ===)

	TCondExprTreeItem(TKeyInfoItem *ki, TLexema &literal_const_value);
			// This is a literal constant. Lexema type should be either number or charconst.
			// (=== cecit_constant ===)

	TCondExprTreeItem(TKeyInfoItem *ki, TLexema &decor_source, TMacroDefinition *mdef, bool def_operation);
			// Result of the trivial macro call scanning. Such result is called "decorated value".
			// (=== cecit_decorated, cecit_name_def ===)

	TCondExprTreeItem(TKeyInfoItem *ki, TLexemasList &src, bool def_operation);
			// Unknown name. The list of source lexemas may contain more than one lexema if the variable in the source
			// code looks like "x(1, 2)".
			// (=== cecit_variable, cecit_variab_def ===)

	TCondExprTreeItem(TLexema &operation_lexema, TCondExprArithmPrt oper_prt);
			// Expression operation. The operation can be unary, binary, etc.
			// (=== cecit_operation ===)

	~TCondExprTreeItem() { operands.DeleteAll(); source.DeleteAll(); }

	enum TAddLexemasMode { alm_primary, alm_secondary, alm_keep_origin };

	void		AddOperand(TCondExprTreeItem *operand, bool add_to_the_end = TRUE);
				// The method is expected to be called only on the operation objects.

	bool		AddSourceLexema(TLexema &source_lex, TAddLexemasMode inc_mode);
	bool		AddSourceLexemasList(TLexemasList &src, bool clone_list, TAddLexemasMode inc_mode);
				// Methods return FALSE only in the out of memory case.

	TCondExprTreeItem *Clone();
				// Method creates a copy of the code tree. When the out of memory case happens during the clonning,
				// the result is NULL.

	bool		IsSimplifiable(TCondExprSimplificationProps &smpl_props);
				// Method returns report on the node itself, not on the subtree. Operations are always simplifiable.

	TCondExprSmplResult SimplifyExpression(TCondExprSimplificationProps &smpl_props);
				// Method removes constant parts from the code. This method expects that all multiple operand
				// operations are commutative. Operation comma is implemented as simple discarding of all
				// operands except the last one.

	bool		CreateTextRepresentation(TTextBuffer256 &result, TCondExprArithmPrt curr_prt = ceprt_lowest);
				// Method generates text representation of the current state of the compiled expression.
				// Return value will be FALSE if code is not in the correct state or if there was a malloc problem.
				// After calling this method app should check the TTextBuffer256 object for the error flag there.

	int		CountNodes();
				// This method recursively counts the number of nodes in the tree.

protected:

	bool			CalcDefinedOperation(TCondExprSimplificationProps &smpl_props);
	bool			CalcOneOperandOperation();
	bool			CalcTwoOperandsOperation();
	bool			CalcMultiOperandsOperation(bool const_align_style, bool merging_happened);
	bool			CalcConditionalOperation();
	bool			CalcCommaOperation();

	static bool	MakeTextReprForOneOperand(TLexema operation, TCondExprArithmPrt opr_prt, TList &operands, TTextBuffer256 &result);
	static bool	MakeTextReprForTwoOperands(TLexema operation, TCondExprArithmPrt opr_prt, TList &operands, TTextBuffer256 &result);
	static bool	MakeTextReprForThreeOperands(TLexema operation, TCondExprArithmPrt opr_prt, TList &operands, TTextBuffer256 &result);
	static bool	MakeTextReprForManyOperands(TLexema operation, TCondExprArithmPrt opr_prt, TList &operands, TTextBuffer256 &result);
	static void	ReportBogusNumberOfOperands(TLexema operation, int num_operands, TTextBuffer256 &result);

	inline bool	IsNumericValue() { return(item_type == cecit_value); }
	void			SetValue(TCondExprIntermediateValue value, bool ext_doubt);
	void			RemoveConstants(TCondExprTreeItem *value_item);
	void			CollectOperandSources(TCondExprTreeItem *except_item);

	inline void	PatchToValue() { item_type = cecit_value; key_info = NULL; }
	void			SetContents(TCondExprTreeItem *item, bool extra_doubt);
					// It is necessary to ensure that the bypassed item is not a member of any list of operands.

public:

	TCondExprTreeItemType		item_type;
									// The type of the code item. This field controls the meaning of other fields below.
									// Note that the tree item can change its type during the expression simplification.
									// This is the primary reason why there are no separate classes for different
									// types of the code items.

	TKeyInfoItem					*key_info;
									// This field is applicable to all types of operands except for "value" and "operation".
									// The pointer points to the cached item and does not need freeing.

	TCondExprIntermediateValue	value;
									// This data member is used as a number for "value", "constant" and "decorated" code items.
									// Note that this is signed value. Current implementation is not designed for correct handling
									// of 64 bit unsigned values. Data items with type "decor_def" and "var_def" use this field
									// as TMacroDefStatus enum. Other types of items do not have any value.

	bool							on_doubt;
									// Doubt stays outside of the value because it turns out that it is applicable
									// to all types of the code items.

	// Data members for "decorated", "decor_def" and "variable" types of items.
	// For "variable" items these fields have non default values if the name is known but is currently undefined.
	ID							decor_cn;
	TMacroDefStatus				decor_state;
	TMacroDefOrigin				decor_nature;
	bool							decor_simplif;

	// Data members for the "operation" type of item.
	TOperatorToken				operation_code;
	TCondExprArithmPrt			operation_prt;
	TList							operands;						// Instances of the TCondExprTreeItem.

	// The source lexemas that were used for building this code item.
	TLexemasList					source;
};

//
// This enum is a set of flags.
//
enum TCondExprScanningMode
{
	cescm_allow_empty_expr = 1,				// When this flag is set, the scanner is not generating syntax error in case of
												// an empty conditional expression.
	cescm_process_commas   = 2,				// When the value of this flag is TRUE, the comma is treated as a valid operation.
												// Otherwise it is treated as separator that stops the expression scanning.
	cescm_allow_unkn_names = 4,				// This option enables/disables generation of a syntax error when an unknown
												// or undefined name is used as an operand of an arithmetic operation. The code
												// tree is generated in the same way regardless of the value of this option.
};

//
// Note:	A macro is considered to be trivial if its body consists of one number or one charconst.
//		All other types of macro bodies including the macro with an empty body are considered
//		to be non trivial.
//

//
// This enum is a set of flags.
//
enum TCondExprScanningDetails
{
	cescd_none = 0,								// Nothing from what is listed below has happened during the conditional
												// expression scanning.
	cescd_nontrivial_macro		= 0x01,			// Non trivial macros were invoked.
	cescd_redefined_predef		= 0x02,			// Redefined predefined condition was used.
	cescd_comment_in_expr		= 0x04,			// Expression contains comments.
	cescd_operand_on_doubt	= 0x08,			// Some operand on doubt was used.
	cescd_operation_on_doubt	= 0x10,			// Operation in the code with doubt status.
	cescd_undef_name_value	= 0x20,			// Undefined name was used as operand.
	cescd_unkn_name_value		= 0x40,			// Unknown name was used as an operand or as a param of
												// the defined operation.
	cescd_unkn_name_def_stt	= 0x80,			// Undefined name was used as an operand. This applies to using
												// it only as an operand, not as param of the defined(x) operation.
	cescd_syntax_error			= 0x100,
	cescd_malloc_problem		= 0x200,
};

struct PrCondParamUseEvent;

class TCondExpressionScanner
{
public:

	TCondExpressionScanner(TMidLevScanner &scanner) : src(scanner) { pdetails = NULL; stk1_len = stk2_len = 0; }
	~TCondExpressionScanner() { while (stk1_len > 0) delete stk1[--stk1_len]; while (stk2_len > 0) delete stk2[--stk2_len]; }

	ID     ScanExpression(ID cond_stmt_cn, int cond_expr_level, TCondExprScanningMode mode,
				TCondExprScanningDetails &scan_res_details, PrEventHeader &cond_expr_area, TLexema &lex_after_expr,
				TCondExprTreeItem **cond_expression_code);

				//
				// Note: The return value is zero if the expression was scanned successfully. Oterwise the return
				// value is the CN of the syntax error. All types of errors are reported to the MidLevScanner inside.
				//
protected:

	enum TCondExpressionScannerState
	{
		cess_left_brace,
		cess_operand,
		cess_pref_unary,		// Unary operation (all unary operatios are prefix ops).
		cess_binary,				// Binary (2 or more opreands) operation.
	};

	bool		ProcessLiteralConstLexema();
	bool		ProcessTokenLexema();
	bool		ProcessNameLexema();
				// When the return value is TRUE, the scaner should continue scanning the expression.
				// Otherwise this is either an syntax error that is already reported or this is an OOM that
				// is not reported yet.

	bool		ProcessDefinedOperation();
	bool		ScanParamsOfAnUnknownMacro(TLexemasList &dest_list);
	bool		ProcessOperand(TCondExprTreeItem *operand, PrEventHeader *spec_error_ctx = NULL);

	ID		ProcessNonExpressionLexema(PrEventHeader &expression_area, TCondExprTreeItem **code, TLexema &lex_after_expr);
	ID		TerminateProcessingExpression();
	ID		TerminateWithError(PrEventHeader &expression_area);

	bool		PushOperation(TLexema &operation_lexema);
	bool		PushOperand(TCondExprTreeItem *operand);

	bool		ResolveStack(TCondExprArithmPrt prt);
	void		AssembleMultiOperandOperation(int stk2_inx_beg, int stk2_inx_end);

private:

	inline void	ReportDetail(TCondExprScanningDetails new_detail) { *pdetails = (TCondExprScanningDetails)((*pdetails) | new_detail); }
	void			PrepareCondParamUseEvent(PrCondParamUseEvent &info, TLexema &lex);

	TLexemaType		ExprScan(bool *ignore_lex_flag = NULL);
						// When the param is not null, the function is giving out every lexema that it encounters.
						// It shows in parameter if it would ignore this lexema if there would be no param specified.

	TLexemaType		ExprScanMacroName();

	void			AssembleExprArea();
	void			ReportError(bool whole_expr, int err_code, PrEventHeader *spec_error_ctx = NULL);

	static TCondExprArithmPrt	GetOperationPriority(TOperatorToken keyword_id);

protected:

	TMidLevScanner				&src;
	TCondExprScanningMode		scan_mode;

	ID							stmt_cn;
	int							stmt_src_level;				// Lex source nesting level of the expression.
	int							stmt_cond_level;			// Conditional nesting level of the expression.
															// These levels can differ from the current levels of the mid lev scanner.
	TCondExpressionScannerState	stt;
	TCondExprScanningDetails		*pdetails;
	bool							malloc_problem;

	TCondExprTreeItem			*stk1[MAX_COND_EXPR_STACK_LEN];		// Stack of operands.
	int							stk1_len;								// The number of occupied slots.
	TCondExprTreeItem			*stk2[MAX_COND_EXPR_STACK_LEN];		// Stack of operations.
	int							stk2_len;								// The number of occupied slots.

	PrEventHeader				expr_area;					// Initially this header corresponds to the first lexema in the expression.
															// Later on this header is adjusted to cover the whole expression.
	PrEventHeader				cmtd_lex_area;				// Source area of the lexema that belongs to the expression for sure.

	TLexema						lex;							// The latest lexema that was retrieved from the source.
															// It may either belong to the epression or not.
	int							lex_src_level;				// The lex source nesting level of the lexema. The value of this field is -1
															// when there is no lexema.
	bool							lex_rescan_req;				// This flag indicates that the data field lex contains lexema that is not
															// processed yet. This is sort of "unscan " mechanism inside of this class.
	ID							latest_error;
};

#endif	// TextScan_CondExpr_H


